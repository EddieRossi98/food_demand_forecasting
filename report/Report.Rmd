---
title: "Food Demand Forecast"
subtitle: "Business, Economic and Financial Data Project"
author: "Pierpaolo D'Odorico, Massimiliano Conte and Eddie Rossi"
output: beamer_presentation
theme: "Berlin"
colortheme: "beaver"
fonttheme: "professionalfonts"
header-includes:
  - \setbeamercolor{structure}{fg=darkred}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(tidyverse)
library(ggplot2)
library(ggcorrplot)
centers = read.csv("../data/fulfilment_center_info.csv")
meals = read.csv("../data/meal_info.csv")
sales = read.csv("../data/train.csv")
```

# Food Demand Forecasting

## **The business problem:**

A **meal delivery company** operates in multiple cities. They have various **fulfillment centers** in these cities for dispatching **meal orders** to their customers.

We need to **forecast** for upcoming weeks, so that these centers will **plan the stock** of raw materials accordingly.

## **Task:**

**Predict the demand** for the next **10 weeks**!

# Data sources

Data are collected in 3 different datasets, connected by keys.

## Datasets

- Fulfilment centers data
- Meal info data
- Sales historical data

# Fulfilment centers data

```{r, echo = F, results = 'asis'}
kable(head(centers,6)) 
```

# Fulfilment centers data features

## **Variables:**

- **center_id**: Fulfilment identifier
- **city_code**: City id in which the center is located on
- **region_code**: Region id in which the center is located on
- **center_type**: Type of the center
- **op_area**: Size of the operational area

## **Unique values in dataset:**

```{r, echo = F, results = 'asis'}
for (col in seq(length(colnames(centers)))){
  cat(colnames(centers)[col],": ")
  cat(dim(unique(centers[col]))[1])
  if (length(colnames(centers)) != col) cat(",  ")
}
```


# Meal info data
```{r, echo = F, results = 'asis'}
kable(head(meals,6)) 
```

# Meal data features

## **Variables:**

- **meal_id**: Meal identifier
- **category**: Category of food
- **cuisine**: Category of cuisine

## **Unique values in dataset:**

```{r, echo = F, results = 'asis'}
for (col in seq(length(colnames(meals)))){
  cat(colnames(meals)[col],": ")
  cat(dim(unique(meals[col]))[1])
  if (length(colnames(meals)) != col) cat(",  ")
}
```

# Meal info data*
```{r, echo = F, results = 'asis'}
kable(head(subset(sales, select = -c(emailer_for_promotion,homepage_featured, checkout_price))
,6))
```

*binomial variables and "checkout_price" are removed for a better dataset view.

# Meal data features

## **Variables:**

- **id**: Id of the single transaction
- **week**: Temporal variable, we have 145 unique weeks
- **center_id**: Fulfilment identifier
- **meal_id**: Meal identifier
- **checkout_price**: Paid price for the product
- **base_price**: Full price of the product without promotion
- **emailer_for_promotion**: Binomial, promotion email or not
- **homepage_featured**: Binomial, product on web homepage
- **num_orders**: Number of orders for the meal and center

# Meal data features

## **Unique values in dataset:**

```{r, echo = F, results = 'asis'}
for (col in seq(length(colnames(sales)))){
  cat(colnames(sales)[col],": ")
  cat(dim(unique(sales[col]))[1])
  if (length(colnames(sales)) != col) cat(",  ")
}
```

# Create a unique dataset

We created a unique dataset **merging by keys**.

There are **0 NA's** in the complete dataset.

We will perform some exploratory data analysis:

- **Univariate Analysis**: Looking at single variables behaviour
- **Multivariate Analysis**: Correlation between variables

``` {r, echo = F, results = 'asis'}
# Create unique dataset
X = merge(sales, centers, by = "center_id")
X = merge(X, meals,by = "meal_id")
```


# Univariate Analysis on numerical variables

We plot boxplots of **numerical variables**:
```{r, echo = F, results = 'asis', out.width="70%",fig.align = 'center'}
par(mfrow = c(2,2))
boxplot(X$checkout_price, main = "checkout_p boxplot", col = "darkred", horizontal=TRUE)
boxplot(X$base_price, main = "base_p boxplot", col = "darkred", horizontal=TRUE)
boxplot(X$op_area, main = "op_area boxplot", col = "darkred", horizontal=TRUE)
boxplot(X$num_orders, main = "num_orders boxplot", col = "darkred", horizontal=TRUE)
par(mfrow = c(1,1))
```


# Univariate Analysis on numerical variables

**num_orders** boxplot vs log transformation for a better view:
```{r, echo = F, results = 'asis', out.width="55%", fig.align = 'center'}
par(mfrow = c(1,2))
boxplot(log(X$num_orders), main = "log(num_orders) boxplot", col = "darkred", horizontal=TRUE)
boxplot(X$num_orders, main = "num_orders boxplot", col = "darkred", horizontal=TRUE)
par(mfrow = c(1,1))
```

High **num_orders** are related to some specific series from a specific center and meal with high demand. For this reason we don't consider them outliers.

# Univariate Analysis on numerical variables

```{r, echo = F, out.width="80%", fig.align='center'}
par(mfrow = c(2,2))
hist(X$checkout_price, col = "darkred", border = "white",xlab = "Price paid", 
     main = "checkout_price density", breaks = 8, probability = T)
hist(X$base_price, col = "darkred", border = "white",xlab = "Initial price ", 
     main = "base_price density", breaks = 8, probability = T)
hist(X$op_area, col = "darkred", border = "white",xlab = "Operational area size", 
     main = "op_area density", breaks = 8, probability = T)
hist(log(X$num_order), col = "darkred", border = "white",xlab = "log(num_orders)", 
     main = "num_orders density", breaks = 10, probability = T)
par(mfrow = c(1,1))
```

# Univariate Analysis on categorical variables

```{r, echo = F, out.width="80%", fig.align='center'}
sums = rep(0,8)
names = levels(factor(centers$region_code))
for (i in 1:8) {
  sums[i] = sum(centers[, "region_code"] == names[i])
}
names = paste("Region", names)
heights = sums/nrow(centers)
b = barplot(names = names , height = heights, 
        col = c("darkred"),
        xlab = "Location",
        ylab = "% of the total centers",
        main = "Region where the centers are located barplot",
        ylim = c(0,0.45))
text(b,heights,labels=sums, adj=c(0.5, -0.5))
```

# Univariate Analysis on categorical variables

**center_type**: There are
```{r, echo = F, results = 'asis'}
cat(length(unique(centers$center_type)))
```
centers types: A, B and C

```{r, echo = F, out.width="65%", fig.align='center'}
sums = c(0,0,0)
names = c("A", "B", "C")
for (i in 1:3) {
  sums[i] = sum(centers[, "center_type"] == paste("TYPE_", names[i], sep = ""))
}
heights = sums/nrow(centers)
b = barplot(names = names , height = heights, 
        col = c("darkred"),
        xlab = "Centers type",
        main = "Barplot of fulfilment centers type",
        ylim = c(0,0.65))
text(b,heights,labels=sums, adj=c(0.5, -0.5))
```

# Univariate Analysis on categorical variables

```{r, echo = F, out.width="85%", fig.align='center'}
ggplot(X, aes(x=category)) + ggtitle("Category relative frequencies") +
  geom_bar(aes(y = (..count..)/sum(..count..)), fill = "darkred") + 
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_y_continuous(labels=scales::percent) + ylab("relative frequencies") + 
  theme_classic(base_size = 15) +
  geom_text(aes( label=paste(as.character(round((..count..)/sum(..count..)*100)),"%",sep = ""),
                 y= (..count..)/sum(..count..) ), stat= "count", vjust = -.3)
```


# Univariate Analysis on categorical variables

```{r, echo = F, out.width="80%", fig.align='center'}
ggplot(X, aes(x=cuisine)) + ggtitle("Cuisine relative frequencies") +
  geom_bar(aes(y = (..count..)/sum(..count..)), fill = "darkred") + 
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_y_continuous(labels=scales::percent) + ylab("relative frequencies") + 
  theme_classic(base_size = 15) +
  geom_text(aes( label=paste(as.character(round((..count..)/sum(..count..)*100)),"%",sep = ""),
                 y= (..count..)/sum(..count..) ), stat= "count", vjust = -.3)
```

# Univariate Analysis on categorical variables

```{r, echo = F, out.width="80%", fig.align='center'}
library(cowplot)

p1 <- ggplot(X, aes(x=emailer_for_promotion)) + ggtitle("Emailer_for_promotion relative") +
  geom_bar(aes(y = (..count..)/sum(..count..)), fill = "darkred") + 
  scale_x_discrete(guide = guide_axis(angle = 90)) +
  scale_y_continuous(labels=scales::percent) + ylab("relative frequencies") + 
  theme_classic(base_size = 15) +
  geom_text(aes( label=paste(as.character(round((..count..)/sum(..count..)*100)),"%",sep = ""),
                 y= (..count..)/sum(..count..) ), stat= "count", vjust = -.3)

p2 <- ggplot(X, aes(x=homepage_featured)) + ggtitle("Homepage_featured relative") +
  geom_bar(aes(y = (..count..)/sum(..count..)), fill = "darkred") + 
  scale_x_discrete(guide = guide_axis(angle = 90)) +
  scale_y_continuous(labels=scales::percent) + ylab("relative frequencies") + 
  theme_classic(base_size = 15) +
  geom_text(aes( label=paste(as.character(round((..count..)/sum(..count..)*100)),"%",sep = ""),
                 y= (..count..)/sum(..count..) ), stat= "count", vjust = -.3)

plot_grid(p1, p2, label_size = 12)
```

# Multivariate Analysis, correlation plot

```{r, echo = F, out.width="55%", fig.align='center'}
library(ggcorrplot)
corr = cor(X[, c(4,5,6,9,13)])
ggcorrplot(corr, hc.order = TRUE, outline.col = "white", 
           colors = c("blue", "white", "darkred"), lab = TRUE) +
  ggtitle("Correlations between numerical variables")
```
num_orders is not highly correlated with other numerical variables.


# Multivariate Analysis, numerical variables

```{r, echo = F, out.width="60%", fig.align='center'}
p1 = ggplot(X, aes(x=checkout_price, y=num_orders)) + geom_point(color = "darkred") + ggtitle("checkout_price vs num_orders") + theme_classic(base_size = 17) 
p2 = ggplot(X, aes(x=base_price, y=num_orders)) + geom_point(color = "darkred") +  ggtitle("darkred vs num_orders") + theme_classic(base_size = 17) 
plot_grid(p1, p2, label_size = 12)
```
We decided to remove checkout_price due to the nature of the variable, in a real case scenario we can't have a checkout price because checkout means that the order is confirmed.


# Multivariate Analysis, numerical variables

```{r, echo = F, out.width="80%", fig.align='center'}
ggplot(X,aes(x=op_area,y=num_orders))+ggtitle("op_area vs num_orders") + geom_point(color = "darkred") + theme_classic(base_size = 17)
```
num_orders seems to increase for bigger op_area centers

# Multivariate Analysis, categorical variables


```{r, echo = F, out.width="80%", fig.align='center'}
ggplot(X, aes(x=center_type, y=log(num_orders))) + geom_boxplot(color="darkred", fill="red", alpha=0.2) + 
  theme(legend.title = element_blank(), legend.position = "none") + ggtitle("center_type vs log(num_orders)") + theme_classic(base_size = 17)
```

# Multivariate Analysis, categorical variables

```{r, echo = F, out.width="80%", fig.align='center'}
ggplot(X, aes(x=category, y=log(num_orders))) + geom_boxplot(color="darkred", fill="red", alpha=0.2) + 
  scale_x_discrete(guide = guide_axis(angle = 60)) +
  theme() + ggtitle("category vs log(num_orders)")+ theme_classic(base_size = 17)
```

# Multivariate Analysis, categorical variables


```{r, echo = F, out.width="80%", fig.align='center'}
ggplot(X, aes(x=cuisine, y=log(num_orders))) +
  geom_boxplot(color="darkred", fill="red", alpha=0.2) + ggtitle("cuisine vs log(num_orders)")+ theme_classic(base_size = 17)
```

# Multivariate Analysis, categorical variables

```{r, echo = F, out.width="80%", fig.align='center'}
X$emailer_for_promotion = as.factor(X$emailer_for_promotion) # convert binomial into factor
X$homepage_featured = as.factor(X$homepage_featured) # convert binomial into factor
p1 = ggplot(X, aes(x=emailer_for_promotion, y=log(num_orders))) + geom_boxplot(color="darkred", fill="red", alpha=0.2) + theme(legend.title = element_blank(), legend.position = "none") +
  ggtitle("email vs log(num_orders)") + theme_classic(base_size = 14)
p2 = ggplot(X, aes(x=homepage_featured, y=log(num_orders))) + geom_boxplot(color="darkred", fill="red", alpha=0.2) + theme(legend.title = element_blank(), legend.position = "none") +
  ggtitle("homepage vs log(num_orders)") + theme_classic(base_size = 14)
plot_grid(p1, p2, label_size = 12)
```
Promotions ad email seem to increase the orders

# Modelling

Since we want to organize the goods for each specific fulflment center, we need to forecast the demand for each specific center. Moreover, we also need to stratify for each unique meal, since each of them requires a different set of raw materials. 
We propose a two-stage approach:

- First we account for the temporal relationship using the linear model, obtaining (hopefully) i.i.d. residuals
- Then we model the obtained residuals, using some flexible method such as the gradient boosting

# Linear model

We want to fit a straight line, between demand and time, for each combination of center and meal. This mean we should fit $N^ocenters \cdot N^omeals \ (77 \cdot 51 = 3927)$ linear models. But if we carefully craft some indicator variables we can specify all the simple linear models in to one single big linear model.

# Linear model

$$Y_{ij} = \beta_{0ij} + \beta_{1ij}week + \mathcal{E}_{ij}$$  $$\forall i=1,...,77; j=1,...,51$$

Is equivalent to:

$$ Y = \beta_{0} + \beta_{1}week + X_{ind} \beta_{level} +  X_{ind}\beta_{slope}\cdot week + \mathcal{E}$$

# Linear model

where $X_{ind}$ is a vector with $51 \cdot77 - 1 = 3926$ columns, and is obtained as the interaction between the dummy expansion of the categorical variables center_id and meal_id. 

The model has $1 + 1 + 3926 + 3926 = 7854$ scalar parameters, that in the simple formulation there are 2 parameters for each model, so $2 \cdot77 \cdot 51 = 7854$



# Validation set and Test set

Dealing with time series data means that standard cross validation is not a viable option, since it breack the temporal dependency. We instead reserved a validation set, taking the last set of observations. The test set are the next 10 week, and the true number of orders stands on Kaggle.

# Validation set and Test set

<<<<<<< HEAD
```{r eval=F, include=FALSE}
=======
```{r, out.width="80%", fig.align='center'}
>>>>>>> e00058d8c608c1823e34ec16e966a2bf76a1839c
meal_feature = as.factor(X$meal_id)
center_feature =as.factor(X$center_id)
week = X$week
y = X$num_orders
ln_y = log(y)

val_idx = which(week > 130)
ggplot(data.frame(x = 1:145), aes(x=unique(week),
                      y=y[X$center_id==77 & X$meal_id ==1062])) +
  geom_line(color="darkred") + 
  xlab("Week") + ylab("Num Orders") +
  geom_vline(xintercept = 110, linetype="dashed", 
                color = "darkblue", size=1) +
  annotate(geom="text", x=60, y=450, label="Training set",
              color="darkblue", fontface =2, size = 5) + 
  annotate(geom="text", x=130, y=450, label="Validation set",
              color="darkblue", fontface =2, size = 5)
```

# Regularization
We added elastic-net regularization in the estimation process:

$$\hat{\beta} = arg\min_{\beta \in \mathbb{R}^p}\left( \sum_{i=1}^n(y_i - x_i^T \beta)^2 + \lambda \sum_{j=1}^p\left( \frac{1}{2}(1-\alpha)\beta_j^2 + \alpha |\beta_j| \right) \right)$$

# No regularization is needed


```{r, eval=T, out.width="80%", fig.align='center'}
Design_matrix = Matrix::sparse.model.matrix( ~ week + meal_feature*center_feature + week*meal_feature*center_feature)
lin_model = glmnet::glmnet(Design_matrix, y, subset = -val_idx, 
                   alpha = 0.8, lambda = c(0, 0.01, 0.1, 1))
loglin_model = glmnet::glmnet(Design_matrix, ln_y, subset = -val_idx, 
                   alpha = 0.8, lambda = c(0, 0.01, 0.1, 1))

y_bar = mean(y[-val_idx])
dummy_val_rmse = sqrt(mean((y_bar - y[val_idx])^2))
dummy_val_mae = mean(abs(y_bar - y[val_idx]))

lin_val_rmse = rep(0, 4)
loglin_val_rmse = rep(0, 4)
lin_val_mae = rep(0, 4)
loglin_val_mae = rep(0, 4)
for(i in 1:4){
  predicted = glmnet::predict.glmnet(lin_model, newx = Design_matrix[val_idx,],s = lin_model$lambda[i])
  lin_val_rmse[i] = sqrt(mean((predicted - y[val_idx])^2))
  lin_val_mae[i] = mean(abs(predicted - y[val_idx]))
}
for(i in 1:4){
  predicted = exp(glmnet::predict.glmnet(loglin_model, newx = Design_matrix[val_idx,],s = lin_model$lambda[i]) )
  loglin_val_rmse[i] = sqrt(mean((predicted- y[val_idx])^2))
  loglin_val_mae[i] = mean(abs(predicted - y[val_idx]))
}

plot(log(lin_model$lambda +0.00001), lin_val_rmse, pch = 16, col="gray",
     ylab = "Validation RMSE", xlab = expression(log(lambda)),
     main = "Error vs regularization strenght", cex = 2)
grid(lwd = 3)
lines(log(lin_model$lambda +0.00001), lin_val_rmse, col ="darkred",lwd=2)
abline(v=log(0.00001), col="darkblue", lty = 2, lwd = 2)
```


<<<<<<< HEAD
```{r, echo = F, eval = F}
kable(data.frame(model = c("Mean", "LM", "LM on ln(y)"), 
=======

# Results on validation set

```{r, eval=T, echo = F}
kable(data.frame(Model = c("Mean", "LM", "LM on ln(y)"), 
>>>>>>> e00058d8c608c1823e34ec16e966a2bf76a1839c
                 RMSE = c(dummy_val_rmse, lin_val_rmse[1], loglin_val_rmse[1]),
                 MAE = c(dummy_val_mae, lin_val_mae[1], loglin_val_mae[1])
                 ))
```









